1. 5 Highest qualities in a compiler:
	1. Needs to build my code
	2. Build my code to assembly correctly, and consistently
	3. needs to build my code so that the program is efficient as can be with given source code.
	4. It needs to assemble my code to be as reliable as can be with given source code.
	5. build as quickly as possible while doing the above.
	Does the list change if I am the compile writer? No, I wouldn't think so, as all of these qualities I would desire as a builder of said system.
	What does my list tell me? that its certainly not an easy job to do, and would require a lot of my time and patience.
2. I would think it would be of interpretation. as interpretation is going from source code directly to actions taken on screen. In this case, the action taken is showing the HTML code and its effects.
3.  
	a. I would imagine that the compiler would be optimized to download the code, then interpret it as soon as it makes sense, and then run it without delay. responsiveness to the user input would be top priority.
	b. This compiler would instead of wasting energy and cycles would probably prioritize the efficiency of the CPU cycles, and of how much power each instruction would use, and choose the balance between low resource usage, and the application being acceptably fast. Also, mobile processors are limited in their instruction set, so they would aim to optimize for the simplified instruction set, rather than a full featured one.
	c. I think, out of all of the compilers talked about so far, this one would do the least amount of optimization possible. Instead, this compiler would prioritize readable assembly code, in an order that makes sense, and no obscure operations to confuse students or the teacher.
	d. Simply put, this compiler would be optimized to split the task evenly among as many processors as possible, in order to more utilize the resources given to it. That would probably involve multithreading, and other more exotic ways of doing multiprocess design. No care would be given to power efficiency, but all of the care would be in using all of the cores as much as possible, or in other words as equally as possible.
	e. I think this compiler would optimize for data integrity first, and compatibility second. Large numerical operations sounds either like mathematics programs, or financial programs. Both of which use large number, or a large amount of numbers. Both of which require the highest precision possible. To be compatible with the a diverse array of processors would mean compatibility with older systems, so this would be a dual concern.
